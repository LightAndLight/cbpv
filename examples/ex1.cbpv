data Sum (a : Val) (b : Val) where { Left[a]; Right[b] }

codata UU (a : Comp) where { faws[] : a }

sumElim = {
  thunk[ 
    \@(a : Val) ->
    \@(b : Val) ->
    \@(r : Comp) ->
    \(f : U (a -> r)) ->
    \(g : U (b -> r)) ->
    \(x : Sum a b) ->
    case x of { 
      Left[a] -> force[f] a; 
      Right[a] -> force[g] a 
    } 
  ]
}

data Tensor (a : Val) (b : Val) where { Tensor[a, b] }

tensorElim = {
  thunk[ 
    \@(a : Val) ->
    \@(b : Val) ->
    \@(r : Comp) ->
    \(f : U (a -> b -> r)) ->
    \(x : Tensor a b) -> 
    case x of { Tensor[a, b] -> force[f] a b } 
  ]
}

data Nat where { Z[]; S[Nat] }

data List (a : Val) where { Nil[]; Cons[a, List a] }

codata Pair (a : Comp) (b : Comp) where {
  fst[] : a;
  snd[] : b
}

codata Stream (a : Comp) where {
  head[] : a;
  tail[] : Stream a
}


takeS = {
  thunk[
  fix self : U (forall (a : Comp). Nat -> U (Stream a) -> F (List (U a))) in
  \@(a : Comp) ->
  \(n : Nat) ->
  \(s : U (Stream a)) ->
  case n of {
    Z[] -> return[Nil[] : List (U a)]; 
    S[k] -> 
      bind 
        rest = force[self] @a k thunk[ force[s].tail[] ]
      in
        return[ Cons[ thunk[ force[s].head[] ], rest ] : List (U a) ]
  }
  ]
}

codata AlephNull where { next[] : AlephNull }
  
infinity = thunk[ fix self : U AlephNull in cocase AlephNull of { next[] -> force[self] } ]

countFrom = {
  thunk[
  fix self : U (Nat -> Stream (F Nat)) in
    \(n : Nat) -> 
    cocase Stream (F Nat) of { 
      head[] -> return[n]; 
      tail[] -> force[self] S[n]
    }
  ]
}